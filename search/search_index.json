{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django REST Framework - Typed \u00b6 Overview \u00b6 This project extends Django REST Framework to allow use of Python's type hints for automatically validating view parameters and generating serializer fields, as well as enabling strongly typed, direct attribute access on serializers. Deriving automatic behavior from type annotations has become increasingly popular with the FastAPI and Django Ninja frameworks. The goal of this project is to provide these benefits to the DRF ecosystem. Main benefits: View inputs can be individually declared, not buried inside all-encompassing request objects. Type annotations can replace repetitive view validation/sanitization code. Simple serializers can have their fields auto-generated from annotations Validated serializer data can be accessed from attributes, with their types known to the IDE Pydantic models are compatible types for view parameters. Annotate your POST/PUT functions with them to automatically validate incoming request bodies. Views Example \u00b6 from rest_typed.views import typed_api_view @typed_api_view ([ \"GET\" ]) def get_users ( registered_on : date = None , groups : List [ int ] = None , staff : bool = None ): print ( registered_on , groups , is_staff ) GET /users/registered/?registered_on= 2019-03-03 &groups= 4,5 &staff= yes # Status code: 200 date ( 2019 , 3 , 3 ) [ 4 , 5 ] True GET /users/?registered_on= 9999 &groups= admin &staff= maybe # Status code: 400 / ValidationError raised { \"registered_on\" : \"'9999' is not a valid date\" , \"groups\" : \"'admin' is not a valid integer\" , \"staff\" : \"'maybe' is not a valid boolean\" } Serializers Example \u00b6 You can use type annotations to generate basic serializer fields automatically. from datetime import date from rest_typed.serializers import TSerializer class MovieSerializer ( TSerializer ): title : str # --> CharField(required=True, allow_null=False) release_date : date # --> DateField(required=True, allow_null=False) description = None # --> DateField(default=None) movie = MovieSerializer ( data = { \"title\" : \"The Last Duel\" , \"release_date\" : \"2021-10-09\" , }) movie . is_valid ( raise_exception = True ) print ( movie . validated_data ) \"\"\" { \"title\": \"The Last Duel\", \"release_date\": date(2021, 10, 9), \"description\": None } \"\"\" Once you've called is_valid() , you can also access validated attributes directly, and if you're using a popular IDE, you should get added type safety: print ( movie . title ) # The Last Duel print ( movie . release_date ) # date(2021, 10, 9) print ( movie . description ) # None IDE can help you understand and enforce types: IDE can auto-complete attributes:","title":"Introduction"},{"location":"#django-rest-framework-typed","text":"","title":"Django REST Framework - Typed"},{"location":"#overview","text":"This project extends Django REST Framework to allow use of Python's type hints for automatically validating view parameters and generating serializer fields, as well as enabling strongly typed, direct attribute access on serializers. Deriving automatic behavior from type annotations has become increasingly popular with the FastAPI and Django Ninja frameworks. The goal of this project is to provide these benefits to the DRF ecosystem. Main benefits: View inputs can be individually declared, not buried inside all-encompassing request objects. Type annotations can replace repetitive view validation/sanitization code. Simple serializers can have their fields auto-generated from annotations Validated serializer data can be accessed from attributes, with their types known to the IDE Pydantic models are compatible types for view parameters. Annotate your POST/PUT functions with them to automatically validate incoming request bodies.","title":"Overview"},{"location":"#views-example","text":"from rest_typed.views import typed_api_view @typed_api_view ([ \"GET\" ]) def get_users ( registered_on : date = None , groups : List [ int ] = None , staff : bool = None ): print ( registered_on , groups , is_staff ) GET /users/registered/?registered_on= 2019-03-03 &groups= 4,5 &staff= yes # Status code: 200 date ( 2019 , 3 , 3 ) [ 4 , 5 ] True GET /users/?registered_on= 9999 &groups= admin &staff= maybe # Status code: 400 / ValidationError raised { \"registered_on\" : \"'9999' is not a valid date\" , \"groups\" : \"'admin' is not a valid integer\" , \"staff\" : \"'maybe' is not a valid boolean\" }","title":"Views Example"},{"location":"#serializers-example","text":"You can use type annotations to generate basic serializer fields automatically. from datetime import date from rest_typed.serializers import TSerializer class MovieSerializer ( TSerializer ): title : str # --> CharField(required=True, allow_null=False) release_date : date # --> DateField(required=True, allow_null=False) description = None # --> DateField(default=None) movie = MovieSerializer ( data = { \"title\" : \"The Last Duel\" , \"release_date\" : \"2021-10-09\" , }) movie . is_valid ( raise_exception = True ) print ( movie . validated_data ) \"\"\" { \"title\": \"The Last Duel\", \"release_date\": date(2021, 10, 9), \"description\": None } \"\"\" Once you've called is_valid() , you can also access validated attributes directly, and if you're using a popular IDE, you should get added type safety: print ( movie . title ) # The Last Duel print ( movie . release_date ) # date(2021, 10, 9) print ( movie . description ) # None IDE can help you understand and enforce types: IDE can auto-complete attributes:","title":"Serializers Example"},{"location":"install/","text":"Install \u00b6 Install using: pip install drf-typed Python 3.8 or higher is required. The only required dependency is Django REST Framework. Optional \u00b6 If you'd like to use Pydantic as an alternative to DRF serializers, you can also install that package: pip install pydantic Don't forget to enable Pydantic as a third-party schema.","title":"Install"},{"location":"install/#install","text":"Install using: pip install drf-typed Python 3.8 or higher is required. The only required dependency is Django REST Framework.","title":"Install"},{"location":"install/#optional","text":"If you'd like to use Pydantic as an alternative to DRF serializers, you can also install that package: pip install pydantic Don't forget to enable Pydantic as a third-party schema.","title":"Optional"},{"location":"serializers/attribute_access/","text":"Typed/Direct Atrribute Access \u00b6 When using TSerializer or TModelSerializer you also have direct access to validated field values after calling is_valid() : from datetime import date from rest_typed.serializers import TSerializer class Genre ( Enum ): comedy = \"comedy\" drama = \"drama\" class MovieSerializer ( TSerializer ): release_date : date genre : Genre cast : List [ str ] movie = MovieSerializer ({ 'release_date' : '2021-10-10' , 'genre' : 'drama' , 'cast' : [ 'Steve Martin' ] }) movie . is_valid () print ( movie . cast ) # ['Steve Martin'] Just like with standard REST Framework serializers, if you attempt to access validated fields before calling is_valid() , an exception will be raised. Now that we're accessing class instance attributes, rather than dictionary keys in .validated_data , the IDE can remind us of the types: It can also help us catch more errors:","title":"Typed/Direct Atrribute Access"},{"location":"serializers/attribute_access/#typeddirect-atrribute-access","text":"When using TSerializer or TModelSerializer you also have direct access to validated field values after calling is_valid() : from datetime import date from rest_typed.serializers import TSerializer class Genre ( Enum ): comedy = \"comedy\" drama = \"drama\" class MovieSerializer ( TSerializer ): release_date : date genre : Genre cast : List [ str ] movie = MovieSerializer ({ 'release_date' : '2021-10-10' , 'genre' : 'drama' , 'cast' : [ 'Steve Martin' ] }) movie . is_valid () print ( movie . cast ) # ['Steve Martin'] Just like with standard REST Framework serializers, if you attempt to access validated fields before calling is_valid() , an exception will be raised. Now that we're accessing class instance attributes, rather than dictionary keys in .validated_data , the IDE can remind us of the types: It can also help us catch more errors:","title":"Typed/Direct Atrribute Access"},{"location":"serializers/ide_integration/","text":"IDE Integration \u00b6 Classes are used to represent serializer fields, which can confuse IDEs into assuming that field values should be instances of those classes, rather than the value type that the class is responsible for validating and deserializing. The project includes a set of type stubs copied from typeddjango/django-stubs (credit due to them for excellent work) and altered to indicate deserialized field types and address the problem stated above. This allows your IDE to know that start_date is of type datetime.date , even though a type annotation was not used.","title":"IDE Integration"},{"location":"serializers/ide_integration/#ide-integration","text":"Classes are used to represent serializer fields, which can confuse IDEs into assuming that field values should be instances of those classes, rather than the value type that the class is responsible for validating and deserializing. The project includes a set of type stubs copied from typeddjango/django-stubs (credit due to them for excellent work) and altered to indicate deserialized field types and address the problem stated above. This allows your IDE to know that start_date is of type datetime.date , even though a type annotation was not used.","title":"IDE Integration"},{"location":"serializers/type_to_field_ref/","text":"Type-to-Field Reference \u00b6 Below is a complete mapping of how native type annotations can be used as shorthand to generate Django REST Framework's serializer fields. Type Field bool serializers.BooleanField date serializers.DateField datetime serializers.DateTimeField float serializers.FloatField int serializers.IntegerField str serializers.CharField time serializers.TimeField timedelta serializers.DurationField UUID serializers.UUIDField Enum serializers.ChoiceField typing.Literal serializers.ChoiceField","title":"Type-to-Field Reference"},{"location":"serializers/type_to_field_ref/#type-to-field-reference","text":"Below is a complete mapping of how native type annotations can be used as shorthand to generate Django REST Framework's serializer fields. Type Field bool serializers.BooleanField date serializers.DateField datetime serializers.DateTimeField float serializers.FloatField int serializers.IntegerField str serializers.CharField time serializers.TimeField timedelta serializers.DurationField UUID serializers.UUIDField Enum serializers.ChoiceField typing.Literal serializers.ChoiceField","title":"Type-to-Field Reference"},{"location":"serializers/typed_serializers/","text":"Auto-Generated Serializer Fields \u00b6 This package provides the following classes: rest_typed.serializers.TSerializer rest_typed.serializers.TModelSerializer They are drop-in replacements for Django REST Framework's serializers.Serializer and serializers.ModelSerializer classes. You can use type annotations as shorthand for declaring serializer fields, similar to how the popular library Pydantic enforces type hints at runtime for data validation. DRF's core field arguments of required , default and allow_null map cleanly to Python's attribute type hints. If you only need to specify those qualities, in addition to the type, you can use annotations instead of field declarations: Simple Example \u00b6 from datetime import date from rest_typed.serializers import TSerializer class BookingSerializer ( TSerializer ): start_date : date end_date : date number_of_people : int = None \"\"\" Same as: class BookingSerializer(serializers.Serializer): start_date = serializers.DateField() end_date = serializers.DateField() number_of_people = serializers.IntegerField(default=None) \"\"\" This approach works well for simple cases, but when you need more complex validation, such as enforcing value ranges or character length, it's best to use standard DRF fields. Enum & Lists Example \u00b6 from datetime import date from rest_typed.serializers import TSerializer class Genre ( Enum ): comedy = \"comedy\" drama = \"drama\" class MovieSerializer ( TSerializer ): release_date : date genre : Genre cast : List [ str ] \"\"\" Same as: class MovieSerializer(serializers.Serializer): release_date = serializers.DateField() genre = serializers.ChoiceField(choices=[\"comedy\", \"drama\"]) cast = serializers.ListField(child=serializers.CharField()) \"\"\" Nested Serializer Example \u00b6 from datetime import date from rest_typed.serializers import TSerializer class ChapterSerializer ( TSerializer ): title : str word_count : int class AuthorSerializer ( TSerializer ): name : str class BookSerializer ( TSerializer ): author : Author chapters : List [ Chapter ] \"\"\" Same as: class BookSerializer(serializers.Serializer): author = AuthorSerializer() chapters = AuthorSerializer(many=True) \"\"\" typing.Literal Example \u00b6 from datetime import date from rest_typed.serializers import TSerializer class MovieSerializer ( TSerializer ): release_date : date genre : Literal [ \"comedy\" , \"drama\" ] cast : List [ str ] \"\"\" Same as: class MovieSerializer(serializers.Serializer): release_date = serializers.DateField() genre = serializers.ChoiceField(choices=[\"comedy\", \"drama\"]) cast = serializers.ListField(child=serializers.CharField()) \"\"\"","title":"Auto-Generated Fields"},{"location":"serializers/typed_serializers/#auto-generated-serializer-fields","text":"This package provides the following classes: rest_typed.serializers.TSerializer rest_typed.serializers.TModelSerializer They are drop-in replacements for Django REST Framework's serializers.Serializer and serializers.ModelSerializer classes. You can use type annotations as shorthand for declaring serializer fields, similar to how the popular library Pydantic enforces type hints at runtime for data validation. DRF's core field arguments of required , default and allow_null map cleanly to Python's attribute type hints. If you only need to specify those qualities, in addition to the type, you can use annotations instead of field declarations:","title":"Auto-Generated Serializer Fields"},{"location":"serializers/typed_serializers/#simple-example","text":"from datetime import date from rest_typed.serializers import TSerializer class BookingSerializer ( TSerializer ): start_date : date end_date : date number_of_people : int = None \"\"\" Same as: class BookingSerializer(serializers.Serializer): start_date = serializers.DateField() end_date = serializers.DateField() number_of_people = serializers.IntegerField(default=None) \"\"\" This approach works well for simple cases, but when you need more complex validation, such as enforcing value ranges or character length, it's best to use standard DRF fields.","title":"Simple Example"},{"location":"serializers/typed_serializers/#enum-lists-example","text":"from datetime import date from rest_typed.serializers import TSerializer class Genre ( Enum ): comedy = \"comedy\" drama = \"drama\" class MovieSerializer ( TSerializer ): release_date : date genre : Genre cast : List [ str ] \"\"\" Same as: class MovieSerializer(serializers.Serializer): release_date = serializers.DateField() genre = serializers.ChoiceField(choices=[\"comedy\", \"drama\"]) cast = serializers.ListField(child=serializers.CharField()) \"\"\"","title":"Enum &amp; Lists Example"},{"location":"serializers/typed_serializers/#nested-serializer-example","text":"from datetime import date from rest_typed.serializers import TSerializer class ChapterSerializer ( TSerializer ): title : str word_count : int class AuthorSerializer ( TSerializer ): name : str class BookSerializer ( TSerializer ): author : Author chapters : List [ Chapter ] \"\"\" Same as: class BookSerializer(serializers.Serializer): author = AuthorSerializer() chapters = AuthorSerializer(many=True) \"\"\"","title":"Nested Serializer Example"},{"location":"serializers/typed_serializers/#typingliteral-example","text":"from datetime import date from rest_typed.serializers import TSerializer class MovieSerializer ( TSerializer ): release_date : date genre : Literal [ \"comedy\" , \"drama\" ] cast : List [ str ] \"\"\" Same as: class MovieSerializer(serializers.Serializer): release_date = serializers.DateField() genre = serializers.ChoiceField(choices=[\"comedy\", \"drama\"]) cast = serializers.ListField(child=serializers.CharField()) \"\"\"","title":"typing.Literal Example"},{"location":"views/advanced_usage/","text":"Advanced Usage \u00b6 Overview \u00b6 For more advanced use cases, you can explicitly declare how each parameter's value is sourced from the request -- from the query parameters, path, body or headers -- as well as define additional validation rules. You import a class named after the request element that is expected to hold the value and assign it to the parameter's default. from rest_typed import typed_api_view , Query , Path @typed_api_view ([ \"GET\" ]) def list_documents ( year : date = Path (), title : str = Query ( default = None )): # ORM logic here... In this example, year is required and must come from the URL path and title is an optional query parameter because the default is set. This is similar to Django REST's serializer fields : passing a default implies that the filed is not required. from rest_typed import typed_api_view , Header @typed_api_view ([ \"GET\" ]) def get_cache_header ( cache : str = Header ()): # ORM logic here... In this example, cache is required and must come from the headers. Additional Validation Rules \u00b6 You can use the request element class ( Query , Path , Body , Header ) to set additional validation constraints. You'll find that these keywords are consistent with Django REST's serializer fields. from rest_typed import typed_api_view , Query , Path @typed_api_view ([ \"GET\" ]) def search_restaurants ( year : date = Path (), rating : int = Query ( default = None , min_value = 1 , max_value = 5 ) ): # ORM logic here... @typed_api_view ([ \"GET\" ]) def get_document ( id : str = Path ( format = \"uuid\" )): # ORM logic here... @typed_api_view ([ \"GET\" ]) def search_users ( email : str = Query ( default = None , format = \"email\" ), ip_address : str = Query ( default = None , format = \"ip\" ), ): # ORM logic here... View a full list of supported types and additional validation rules. Nested Body Fields \u00b6 Similar to how source is used in Django REST to control field mappings during serialization, you can use it to specify the exact path to the request data. from pydantic import BaseModel from rest_typed import typed_api_view , Query , Path class Document ( BaseModel ): title : str body : str \"\"\" POST { \"strict\": false, \"data\": { \"title\": \"A Dark and Stormy Night\", \"body\": \"Once upon a time\" } } \"\"\" @typed_api_view ([ \"POST\" ]) def create_document ( strict_mode : bool = Body ( source = \"strict\" ), item : Document = Body ( source = \"data\" ) ): # ORM logic here... You can also use dot-notation to source data multiple levels deep in the JSON payload. List Validation \u00b6 For the basic case of list validation - validating types within a comma-delimited string - declare the type to get automatic validation/coercion: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_movies ( item_ids : List [ int ] = [])): print ( item_ids ) # GET /movies?items_ids=41,64,3 # [41, 64, 3] But you can also specify min_length and max_length , as well as the delimiter and specify additional rules for the child items -- think Django REST's ListField . Import the generic Param class and use it to set the rules for the child elements: from rest_typed import typed_api_view , Query , Param @typed_api_view ([ \"GET\" ]) def search_outcomes ( scores : List [ int ] = Query ( delimiter = \"|\" , child = Param ( min_value = 0 , max_value = 100 )) ): # ORM logic ... @typed_api_view ([ \"GET\" ]) def search_message ( recipients : List [ str ] = Query ( min_length = 1 , max_length = 10 , child = Param ( format = \"email\" )) ): # ORM logic ... Accessing the Request Object \u00b6 You probably won't need to access the request object directly, as this package will provide its relevant properties as view arguments. However, you can include it as a parameter annotated with its type and it will be injected: from rest_framework.request import Request from rest_typed import typed_api_view @typed_api_view ([ \"GET\" ]) def search_documens ( request : Request , q : str = None ): # ORM logic ... Interdependent Query Parameter Validation \u00b6 Often, it's useful to validate a combination of query parameters - for instance, a start_date shouldn't come after an end_date . You can use complex schema object (Pydantic) for this scenario. In the example below, Query(source=\"*\") is instructing an instance of SearchParamsSchema to be populated/validated using all of the query parameters together: request.query_params.dict() . from pydantic import BaseModel from rest_typed import typed_api_view class SearchParamsSchema ( BaseModel ): start_date = fields . Date () end_date = fields . Date () @root_validator def validate_dates ( cls , values ): if values [ \"start_date\" ] >= values [ \"end_date\" ]: raise ValueError ( \"end_date must come after start_date\" ) @typed_api_view ([ \"GET\" ]) def search_documens ( search_params : SearchParamsSchema = Query ( source = \"*\" )): # ORM logic ... (Simple) Access Control \u00b6 You can apply some very basic access control by applying some validation rules to a view parameter sourced from the CurrentUser request element class. In the example below, a ValidationError will be raised if the request.user is not a member of either super_users or admins . from my_pydantic_schemas import BookingSchema from rest_typed import typed_api_view , CurrentUser @typed_api_view ([ \"POST\" ]) def create_booking ( booking : BookingSchema , user : User = CurrentUser ( member_of_any = [ \"super_users\" , \"admins\" ]) ): # Do something with the request.user Read more about the Current User request element class .","title":"Advanced Usage"},{"location":"views/advanced_usage/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"views/advanced_usage/#overview","text":"For more advanced use cases, you can explicitly declare how each parameter's value is sourced from the request -- from the query parameters, path, body or headers -- as well as define additional validation rules. You import a class named after the request element that is expected to hold the value and assign it to the parameter's default. from rest_typed import typed_api_view , Query , Path @typed_api_view ([ \"GET\" ]) def list_documents ( year : date = Path (), title : str = Query ( default = None )): # ORM logic here... In this example, year is required and must come from the URL path and title is an optional query parameter because the default is set. This is similar to Django REST's serializer fields : passing a default implies that the filed is not required. from rest_typed import typed_api_view , Header @typed_api_view ([ \"GET\" ]) def get_cache_header ( cache : str = Header ()): # ORM logic here... In this example, cache is required and must come from the headers.","title":"Overview"},{"location":"views/advanced_usage/#additional-validation-rules","text":"You can use the request element class ( Query , Path , Body , Header ) to set additional validation constraints. You'll find that these keywords are consistent with Django REST's serializer fields. from rest_typed import typed_api_view , Query , Path @typed_api_view ([ \"GET\" ]) def search_restaurants ( year : date = Path (), rating : int = Query ( default = None , min_value = 1 , max_value = 5 ) ): # ORM logic here... @typed_api_view ([ \"GET\" ]) def get_document ( id : str = Path ( format = \"uuid\" )): # ORM logic here... @typed_api_view ([ \"GET\" ]) def search_users ( email : str = Query ( default = None , format = \"email\" ), ip_address : str = Query ( default = None , format = \"ip\" ), ): # ORM logic here... View a full list of supported types and additional validation rules.","title":"Additional Validation Rules"},{"location":"views/advanced_usage/#nested-body-fields","text":"Similar to how source is used in Django REST to control field mappings during serialization, you can use it to specify the exact path to the request data. from pydantic import BaseModel from rest_typed import typed_api_view , Query , Path class Document ( BaseModel ): title : str body : str \"\"\" POST { \"strict\": false, \"data\": { \"title\": \"A Dark and Stormy Night\", \"body\": \"Once upon a time\" } } \"\"\" @typed_api_view ([ \"POST\" ]) def create_document ( strict_mode : bool = Body ( source = \"strict\" ), item : Document = Body ( source = \"data\" ) ): # ORM logic here... You can also use dot-notation to source data multiple levels deep in the JSON payload.","title":"Nested Body Fields"},{"location":"views/advanced_usage/#list-validation","text":"For the basic case of list validation - validating types within a comma-delimited string - declare the type to get automatic validation/coercion: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_movies ( item_ids : List [ int ] = [])): print ( item_ids ) # GET /movies?items_ids=41,64,3 # [41, 64, 3] But you can also specify min_length and max_length , as well as the delimiter and specify additional rules for the child items -- think Django REST's ListField . Import the generic Param class and use it to set the rules for the child elements: from rest_typed import typed_api_view , Query , Param @typed_api_view ([ \"GET\" ]) def search_outcomes ( scores : List [ int ] = Query ( delimiter = \"|\" , child = Param ( min_value = 0 , max_value = 100 )) ): # ORM logic ... @typed_api_view ([ \"GET\" ]) def search_message ( recipients : List [ str ] = Query ( min_length = 1 , max_length = 10 , child = Param ( format = \"email\" )) ): # ORM logic ...","title":"List Validation"},{"location":"views/advanced_usage/#accessing-the-request-object","text":"You probably won't need to access the request object directly, as this package will provide its relevant properties as view arguments. However, you can include it as a parameter annotated with its type and it will be injected: from rest_framework.request import Request from rest_typed import typed_api_view @typed_api_view ([ \"GET\" ]) def search_documens ( request : Request , q : str = None ): # ORM logic ...","title":"Accessing the Request Object"},{"location":"views/advanced_usage/#interdependent-query-parameter-validation","text":"Often, it's useful to validate a combination of query parameters - for instance, a start_date shouldn't come after an end_date . You can use complex schema object (Pydantic) for this scenario. In the example below, Query(source=\"*\") is instructing an instance of SearchParamsSchema to be populated/validated using all of the query parameters together: request.query_params.dict() . from pydantic import BaseModel from rest_typed import typed_api_view class SearchParamsSchema ( BaseModel ): start_date = fields . Date () end_date = fields . Date () @root_validator def validate_dates ( cls , values ): if values [ \"start_date\" ] >= values [ \"end_date\" ]: raise ValueError ( \"end_date must come after start_date\" ) @typed_api_view ([ \"GET\" ]) def search_documens ( search_params : SearchParamsSchema = Query ( source = \"*\" )): # ORM logic ...","title":"Interdependent Query Parameter Validation"},{"location":"views/advanced_usage/#simple-access-control","text":"You can apply some very basic access control by applying some validation rules to a view parameter sourced from the CurrentUser request element class. In the example below, a ValidationError will be raised if the request.user is not a member of either super_users or admins . from my_pydantic_schemas import BookingSchema from rest_typed import typed_api_view , CurrentUser @typed_api_view ([ \"POST\" ]) def create_booking ( booking : BookingSchema , user : User = CurrentUser ( member_of_any = [ \"super_users\" , \"admins\" ]) ): # Do something with the request.user Read more about the Current User request element class .","title":"(Simple) Access Control"},{"location":"views/request_elements/","text":"Request Elements \u00b6 Overview \u00b6 You can specify the part of the request that holds each view parameter by using default function arguments, for example: from rest_typed import Body , Query @typed_api_view ([ \"PUT\" ]) def update_user ( user : UserSchema = Body (), optimistic_update : bool = Query ( default = False ) ): The user parameter will come from the request body and is required because no default is provided. Meanwhile, optimistic_update is not required and will be populated from a query parameter with the same name. The core keyword arguments to these classes are: default the default value for the parameter, which is required unless set source if the view parameter has a different name than its key embedded in the request Passing keywords for additional validation constraints is a powerful capability that gets you almost the same feature set as Django REST's flexible serializer fields . See a complete list of validation keywords. Query \u00b6 Use the source argument to alias the parameter value and pass keywords to set additional constraints. For example, your query parameters can have dashes, but be mapped to a parameter that have underscores: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_events ( starting_after : date = Query ( source = \"starting-after\" ), available_tickets : int = Query ( default = 0 , min_value = 0 ) ): # ORM logic here... Body \u00b6 By default, the entire request body is used to populate parameters marked with this class ( source=\"*\" ): from rest_typed import typed_api_view , Body from my_pydantic_schemas import ResidenceListing @typed_api_view ([ \"POST\" ]) def create_listing ( residence : ResidenceListing = Body ()): # ORM logic ... However, you can also specify nested fields in the request body, with support for dot notation. \"\"\" POST /users/ { \"first_name\": \"Homer\", \"last_name\": \"Simpson\", \"contact\": { \"phone\" : \"800-123-456\", \"fax\": \"13235551234\" } } \"\"\" from rest_typed import typed_api_view , Body @typed_api_view ([ \"POST\" ]) def create_user ( first_name : str = Body ( source = \"first_name\" ), last_name : str = Body ( source = \"last_name\" ), phone : str = Body ( source = \"contact.phone\" , min_length = 10 , max_length = 20 ) ): # ORM logic ... Path \u00b6 Use the source argument to alias a view parameter name. More commonly, though, you can set additional validation rules for parameters coming from the URL path. from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def retrieve_event ( id : int = Path ( min_value = 0 , max_value = 1000 )): # ORM logic here... Header \u00b6 Use the Header request element class to automatically retrieve a value from a header. Underscores in variable names are automatically converted to dashes. from rest_typed import typed_api_view , Header @typed_api_view ([ \"GET\" ]) def retrieve_event ( id : int , cache_control : str = Header ( default = \"no-cache\" )): # ORM logic here... If you prefer, you can explicitly specify the exact header key: from rest_typed import typed_api_view , Header @typed_api_view ([ \"GET\" ]) def retrieve_event ( id : int , cache_control : str = Header ( source = \"cache-control\" , default = \"no-cache\" )): # ORM logic here... CurrentUser \u00b6 Use this class to have a view parameter populated with the current user of the request. You can even extract fields from the current user using the source option. from my_pydantic_schemas import BookingSchema from rest_typed import typed_api_view , CurrentUser @typed_api_view ([ \"POST\" ]) def create_booking ( booking : BookingSchema , user : User = CurrentUser ()): # Do something with the request.user @typed_api_view ([ \"GET\" ]) def retrieve_something ( first_name : str = CurrentUser ( source = \"first_name\" )): # Do something with the request.user's first name You can also pass some additional parameters to the CurrentUser request element class to implement simple access control: member_of (str) Validates that the current request.user is a member of a group with this name member_of_any (List[str]) Validates that the current request.user is a member of one of these groups Using these keyword validators assumes that your User model has a many-to-many relationship with django.contrib.auth.models.Group via user.groups . An example: from django.contrib.auth.models import User from rest_typed import typed_api_view , CurrentUser @typed_api_view ([ \"GET\" ]) def do_something ( user : User = CurrentUser ( member_of = \"admin\" )): # now have a user instance (assuming ValidationError wasn't raised)","title":"Request Elements"},{"location":"views/request_elements/#request-elements","text":"","title":"Request Elements"},{"location":"views/request_elements/#overview","text":"You can specify the part of the request that holds each view parameter by using default function arguments, for example: from rest_typed import Body , Query @typed_api_view ([ \"PUT\" ]) def update_user ( user : UserSchema = Body (), optimistic_update : bool = Query ( default = False ) ): The user parameter will come from the request body and is required because no default is provided. Meanwhile, optimistic_update is not required and will be populated from a query parameter with the same name. The core keyword arguments to these classes are: default the default value for the parameter, which is required unless set source if the view parameter has a different name than its key embedded in the request Passing keywords for additional validation constraints is a powerful capability that gets you almost the same feature set as Django REST's flexible serializer fields . See a complete list of validation keywords.","title":"Overview"},{"location":"views/request_elements/#query","text":"Use the source argument to alias the parameter value and pass keywords to set additional constraints. For example, your query parameters can have dashes, but be mapped to a parameter that have underscores: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_events ( starting_after : date = Query ( source = \"starting-after\" ), available_tickets : int = Query ( default = 0 , min_value = 0 ) ): # ORM logic here...","title":"Query"},{"location":"views/request_elements/#body","text":"By default, the entire request body is used to populate parameters marked with this class ( source=\"*\" ): from rest_typed import typed_api_view , Body from my_pydantic_schemas import ResidenceListing @typed_api_view ([ \"POST\" ]) def create_listing ( residence : ResidenceListing = Body ()): # ORM logic ... However, you can also specify nested fields in the request body, with support for dot notation. \"\"\" POST /users/ { \"first_name\": \"Homer\", \"last_name\": \"Simpson\", \"contact\": { \"phone\" : \"800-123-456\", \"fax\": \"13235551234\" } } \"\"\" from rest_typed import typed_api_view , Body @typed_api_view ([ \"POST\" ]) def create_user ( first_name : str = Body ( source = \"first_name\" ), last_name : str = Body ( source = \"last_name\" ), phone : str = Body ( source = \"contact.phone\" , min_length = 10 , max_length = 20 ) ): # ORM logic ...","title":"Body"},{"location":"views/request_elements/#path","text":"Use the source argument to alias a view parameter name. More commonly, though, you can set additional validation rules for parameters coming from the URL path. from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def retrieve_event ( id : int = Path ( min_value = 0 , max_value = 1000 )): # ORM logic here...","title":"Path"},{"location":"views/request_elements/#header","text":"Use the Header request element class to automatically retrieve a value from a header. Underscores in variable names are automatically converted to dashes. from rest_typed import typed_api_view , Header @typed_api_view ([ \"GET\" ]) def retrieve_event ( id : int , cache_control : str = Header ( default = \"no-cache\" )): # ORM logic here... If you prefer, you can explicitly specify the exact header key: from rest_typed import typed_api_view , Header @typed_api_view ([ \"GET\" ]) def retrieve_event ( id : int , cache_control : str = Header ( source = \"cache-control\" , default = \"no-cache\" )): # ORM logic here...","title":"Header"},{"location":"views/request_elements/#currentuser","text":"Use this class to have a view parameter populated with the current user of the request. You can even extract fields from the current user using the source option. from my_pydantic_schemas import BookingSchema from rest_typed import typed_api_view , CurrentUser @typed_api_view ([ \"POST\" ]) def create_booking ( booking : BookingSchema , user : User = CurrentUser ()): # Do something with the request.user @typed_api_view ([ \"GET\" ]) def retrieve_something ( first_name : str = CurrentUser ( source = \"first_name\" )): # Do something with the request.user's first name You can also pass some additional parameters to the CurrentUser request element class to implement simple access control: member_of (str) Validates that the current request.user is a member of a group with this name member_of_any (List[str]) Validates that the current request.user is a member of one of these groups Using these keyword validators assumes that your User model has a many-to-many relationship with django.contrib.auth.models.Group via user.groups . An example: from django.contrib.auth.models import User from rest_typed import typed_api_view , CurrentUser @typed_api_view ([ \"GET\" ]) def do_something ( user : User = CurrentUser ( member_of = \"admin\" )): # now have a user instance (assuming ValidationError wasn't raised)","title":"CurrentUser "},{"location":"views/simple_usage/","text":"Typed Views \u00b6 Simple Usage \u00b6 For many cases, you can rely on implicit behavior for how different parts of the request (URL path variables, query parameters, body) map to the parameters of a view function/method. The value of a view parameter will come from... the URL path if the path variable and the view argument have the same name, or : the request body if the view argument is annotated using a class from a supported library for complex object validation (Pydantic), or : a query parameter with the same name Unless a default value is given, the parameter is required and a ValidationError will be raised if not set. Basic GET Request \u00b6 urlpatterns = [ url ( r \"^(?P<city>[\\w+])/restaurants/\" , search_restaurants ) ] from rest_typed import typed_api_view # Example request: /chicago/restaurants?delivery=yes @typed_api_view ([ \"GET\" ]) def search_restaurants ( city : str , rating : float = None , offers_delivery : bool = None ): restaurants = Restaurant . objects . filter ( city = city ) if rating is not None : restaurants = restaurants . filter ( rating__gte = rating ) if offers_delivery is not None : restaurants = restaurants . filter ( delivery = offers_delivery ) In this example, city is required and must be its string. Its value comes from the URL path variable with the same name. The other parameters, rating and offers_delivery , are not part of the path parameters and are assumed to be query parameters. They both have a default value, so they are optional. Basic POST Request \u00b6 # urls.py urlpatterns = [ url ( r \"^(?P<city>[\\w+])/bookings/\" , create_booking )] # settings.py DRF_TYPED_VIEWS = { \"schema_packages\" : [ \"pydantic\" ]} # views.py from pydantic import BaseModel from rest_typed import typed_api_view class RoomEnum ( str , Enum ): double = 'double' twin = 'twin' single = 'single' class BookingSchema ( BaseModel ): start_date : date end_date : date room : RoomEnum = RoomEnum . double include_breakfast : bool = False # Example request: /chicago/bookings/ @typed_api_view ([ \"POST\" ]) def create_booking ( city : str , booking : BookingSchema ): # do something with the validated booking... In this example, city will again be populated using the URL path variable. The booking parameter is annotated using a supported complex schema class (Pydantic), so it's assumed to come from the request body, which will be read in as JSON, used to hydrate the Pydantic BookingSchema and then validated. If validation fails a ValidationError will be raised.","title":"Basic Usage"},{"location":"views/simple_usage/#typed-views","text":"","title":"Typed Views"},{"location":"views/simple_usage/#simple-usage","text":"For many cases, you can rely on implicit behavior for how different parts of the request (URL path variables, query parameters, body) map to the parameters of a view function/method. The value of a view parameter will come from... the URL path if the path variable and the view argument have the same name, or : the request body if the view argument is annotated using a class from a supported library for complex object validation (Pydantic), or : a query parameter with the same name Unless a default value is given, the parameter is required and a ValidationError will be raised if not set.","title":"Simple Usage"},{"location":"views/simple_usage/#basic-get-request","text":"urlpatterns = [ url ( r \"^(?P<city>[\\w+])/restaurants/\" , search_restaurants ) ] from rest_typed import typed_api_view # Example request: /chicago/restaurants?delivery=yes @typed_api_view ([ \"GET\" ]) def search_restaurants ( city : str , rating : float = None , offers_delivery : bool = None ): restaurants = Restaurant . objects . filter ( city = city ) if rating is not None : restaurants = restaurants . filter ( rating__gte = rating ) if offers_delivery is not None : restaurants = restaurants . filter ( delivery = offers_delivery ) In this example, city is required and must be its string. Its value comes from the URL path variable with the same name. The other parameters, rating and offers_delivery , are not part of the path parameters and are assumed to be query parameters. They both have a default value, so they are optional.","title":"Basic GET Request"},{"location":"views/simple_usage/#basic-post-request","text":"# urls.py urlpatterns = [ url ( r \"^(?P<city>[\\w+])/bookings/\" , create_booking )] # settings.py DRF_TYPED_VIEWS = { \"schema_packages\" : [ \"pydantic\" ]} # views.py from pydantic import BaseModel from rest_typed import typed_api_view class RoomEnum ( str , Enum ): double = 'double' twin = 'twin' single = 'single' class BookingSchema ( BaseModel ): start_date : date end_date : date room : RoomEnum = RoomEnum . double include_breakfast : bool = False # Example request: /chicago/bookings/ @typed_api_view ([ \"POST\" ]) def create_booking ( city : str , booking : BookingSchema ): # do something with the validated booking... In this example, city will again be populated using the URL path variable. The booking parameter is annotated using a supported complex schema class (Pydantic), so it's assumed to come from the request body, which will be read in as JSON, used to hydrate the Pydantic BookingSchema and then validated. If validation fails a ValidationError will be raised.","title":"Basic POST Request"},{"location":"views/supported_types/","text":"Supported Types and Validator Rules \u00b6 Overview \u00b6 The following native Python types are supported. Depending on the type, you can pass additional validation rules to the request element class ( Query , Path , Body ). You can think of the type combining with the validation rules to create a Django REST serializer field on the fly -- in fact, that's what happens behind the scenes. str \u00b6 Additional arguments: max_length Validates that the input contains no more than this number of characters. min_length Validates that the input contains no fewer than this number of characters. trim_whitespace (bool; default True ) Whether to trim leading and trailing white space. format Validates that the string matches a common format; supported values: email validates the text to be a valid e-mail address. slug validates the input against the pattern [a-zA-Z0-9_-]+ . uuid validates the input is a valid UUID string url validates fully qualified URLs of the form http://<host>/<path> ip validates input is a valid IPv4 or IPv6 string ipv4 validates input is a valid IPv4 string ipv6 validates input is a valid IPv6 string file_path validates that the input corresponds to filenames in a certain directory on the filesystem; allows all the same keyword arguments as Django REST's FilePathField Some examples: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_users ( email : str = Query ( format = 'email' )): # ORM logic here... return Response ( data ) @typed_api_view ([ \"GET\" ]) def search_shared_links ( url : str = Query ( default = None , format = 'url' )): # ORM logic here... return Response ( data ) @typed_api_view ([ \"GET\" ]) def search_request_logs ( ip_address : str = Query ( default = None , format = 'ip' )): # ORM logic here... return Response ( data ) int \u00b6 Additional arguments: max_value Validate that the number provided is no greater than this value. min_value Validate that the number provided is no less than this value. An example: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_products ( inventory : int = Query ( min_value = 0 )): # ORM logic here... float \u00b6 Additional arguments: max_value Validate that the number provided is no greater than this value. min_value Validate that the number provided is no less than this value. An example: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_products ( price : float = Query ( min_value = 0 )): # ORM logic here... Decimal \u00b6 Additional arguments: max_value Validate that the number provided is no greater than this value. min_value Validate that the number provided is no less than this value. .. even more ... accepts the same arguments as Django REST's DecimalField bool \u00b6 View parameters annotated with this type will validate and coerce the same values as Django REST's BooleanField , including but not limited to the following: true_values = [ \"yes\" , 1 , \"on\" , \"y\" , \"true\" ] false_values = [ \"no\" , 0 , \"off\" , \"n\" , \"false\" ] datetime \u00b6 Additional arguments: input_formats A list of input formats which may be used to parse the date-time, defaults to Django's DATETIME_INPUT_FORMATS settings, which defaults to ['iso-8601'] default_timezone A pytz.timezone of the timezone. If not specified, falls back to Django's USE_TZ setting. date \u00b6 Additional arguments: input_formats A list of input formats which may be used to parse the date, defaults to Django's DATETIME_INPUT_FORMATS settings, which defaults to ['iso-8601'] time \u00b6 Additional arguments: input_formats A list of input formats which may be used to parse the time, defaults to Django's TIME_INPUT_FORMATS settings, which defaults to ['iso-8601'] timedelta \u00b6 Validates strings of the format '[DD] [HH:[MM:]]ss[.uuuuuu]' and converts them to a datetime.timedelta instance. Additional arguments: max_value Validate that the input duration is no greater than this value. min_value Validate that the input duration is no less than this value. List \u00b6 Validates strings of the format '[DD] [HH:[MM:]]ss[.uuuuuu]' and converts them to a datetime.timedelta instance. Additional arguments: min_length Validates that the list contains no fewer than this number of elements. max_length Validates that the list contains no more than this number of elements. child Pass keyword constraints via a Param instance to to validate the members of the list. An example: from rest_typed import typed_api_view , Param , Query @typed_api_view ([ \"GET\" ]) def search_contacts ( emails : List [ str ] = Query ( max_length = 10 , child = Param ( format = \"email\" ))): # ORM logic here... Enum \u00b6 Validates that the value of the input is one of a limited set of choices. Think of this as mapping to a Django REST ChoiceField . An example: from rest_typed import typed_api_view , Query class Straws ( str , Enum ): paper = \"paper\" plastic = \"plastic\" @typed_api_view ([ \"GET\" ]) def search_straws ( type : Straws = None ): # ORM logic here... typing.Literal \u00b6 As an alternative to Enum , typing.Literal can validate that the value of the input is one of a limited set of choices. Think of this as mapping to a Django REST ChoiceField . An example: from typing import Literal @typed_api_view ([ \"GET\" ]) def search_straws ( type : Literal [ \"paper\" , \"plastic\" ] = None ): # ORM logic here... Django REST Framework Serializers \u00b6 You can annotate view parameters with Django Rest serializers to validate request data and pass an instance of the serializer to the view. from rest_framework import serializers from rest_typed import typed_api_view class CommentSerializer ( serializers . Serializer ): email = serializers . EmailField () content = serializers . CharField ( max_length = 200 ) created = serializers . DateTimeField ( read_only = True ) \"\"\" POST { \"email\": \"mscott@paperco.com\", \"content\": \"great job team!\", } \"\"\" @typed_api_view ([ \"POST\" ]) def create_comment ( comment : CommentSerializer ): # is_valid() automatically called. # ready to access comment.validated_data DRF Typed - TSerializers \u00b6 You can annotate view parameters with DRF Typed's TSerializers to validate request data and pass an instance of the serializer to the view. from rest_typed.serializers import TSerializer from rest_typed import typed_api_view from datetime import datetime class CommentSerializer ( TSerializer ): email : str content : str created : datetime = serializers . DateTimeField ( read_only = True ) \"\"\" POST { \"email\": \"mscott@paperco.com\", \"content\": \"great job team!\", } \"\"\" @typed_api_view ([ \"POST\" ]) def create_comment ( comment : CommentSerializer ): # is_valid() automatically called. # ready to access comment.email and comment.content pydantic.BaseModel \u00b6 You can annotate view parameters with Pydantic models to validate request data and pass an instance of the model to the view. from pydantic import BaseModel from rest_typed import typed_api_view , Query class User ( BaseModel ): id : int name : str signup_ts : datetime = None friends : List [ int ] = [] \"\"\" POST { \"id\": 24529782, \"name\": \"Michael Scott\", \"friends\": [24529782] } \"\"\" @typed_api_view ([ \"POST\" ]) def create_user ( user : User ): # now have a user instance (assuming ValidationError wasn't raised)","title":"Supported Types"},{"location":"views/supported_types/#supported-types-and-validator-rules","text":"","title":"Supported Types and Validator Rules"},{"location":"views/supported_types/#overview","text":"The following native Python types are supported. Depending on the type, you can pass additional validation rules to the request element class ( Query , Path , Body ). You can think of the type combining with the validation rules to create a Django REST serializer field on the fly -- in fact, that's what happens behind the scenes.","title":"Overview"},{"location":"views/supported_types/#str","text":"Additional arguments: max_length Validates that the input contains no more than this number of characters. min_length Validates that the input contains no fewer than this number of characters. trim_whitespace (bool; default True ) Whether to trim leading and trailing white space. format Validates that the string matches a common format; supported values: email validates the text to be a valid e-mail address. slug validates the input against the pattern [a-zA-Z0-9_-]+ . uuid validates the input is a valid UUID string url validates fully qualified URLs of the form http://<host>/<path> ip validates input is a valid IPv4 or IPv6 string ipv4 validates input is a valid IPv4 string ipv6 validates input is a valid IPv6 string file_path validates that the input corresponds to filenames in a certain directory on the filesystem; allows all the same keyword arguments as Django REST's FilePathField Some examples: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_users ( email : str = Query ( format = 'email' )): # ORM logic here... return Response ( data ) @typed_api_view ([ \"GET\" ]) def search_shared_links ( url : str = Query ( default = None , format = 'url' )): # ORM logic here... return Response ( data ) @typed_api_view ([ \"GET\" ]) def search_request_logs ( ip_address : str = Query ( default = None , format = 'ip' )): # ORM logic here... return Response ( data )","title":"str"},{"location":"views/supported_types/#int","text":"Additional arguments: max_value Validate that the number provided is no greater than this value. min_value Validate that the number provided is no less than this value. An example: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_products ( inventory : int = Query ( min_value = 0 )): # ORM logic here...","title":"int"},{"location":"views/supported_types/#float","text":"Additional arguments: max_value Validate that the number provided is no greater than this value. min_value Validate that the number provided is no less than this value. An example: from rest_typed import typed_api_view , Query @typed_api_view ([ \"GET\" ]) def search_products ( price : float = Query ( min_value = 0 )): # ORM logic here...","title":"float"},{"location":"views/supported_types/#decimal","text":"Additional arguments: max_value Validate that the number provided is no greater than this value. min_value Validate that the number provided is no less than this value. .. even more ... accepts the same arguments as Django REST's DecimalField","title":"Decimal"},{"location":"views/supported_types/#bool","text":"View parameters annotated with this type will validate and coerce the same values as Django REST's BooleanField , including but not limited to the following: true_values = [ \"yes\" , 1 , \"on\" , \"y\" , \"true\" ] false_values = [ \"no\" , 0 , \"off\" , \"n\" , \"false\" ]","title":"bool"},{"location":"views/supported_types/#datetime","text":"Additional arguments: input_formats A list of input formats which may be used to parse the date-time, defaults to Django's DATETIME_INPUT_FORMATS settings, which defaults to ['iso-8601'] default_timezone A pytz.timezone of the timezone. If not specified, falls back to Django's USE_TZ setting.","title":"datetime"},{"location":"views/supported_types/#date","text":"Additional arguments: input_formats A list of input formats which may be used to parse the date, defaults to Django's DATETIME_INPUT_FORMATS settings, which defaults to ['iso-8601']","title":"date"},{"location":"views/supported_types/#time","text":"Additional arguments: input_formats A list of input formats which may be used to parse the time, defaults to Django's TIME_INPUT_FORMATS settings, which defaults to ['iso-8601']","title":"time"},{"location":"views/supported_types/#timedelta","text":"Validates strings of the format '[DD] [HH:[MM:]]ss[.uuuuuu]' and converts them to a datetime.timedelta instance. Additional arguments: max_value Validate that the input duration is no greater than this value. min_value Validate that the input duration is no less than this value.","title":"timedelta"},{"location":"views/supported_types/#list","text":"Validates strings of the format '[DD] [HH:[MM:]]ss[.uuuuuu]' and converts them to a datetime.timedelta instance. Additional arguments: min_length Validates that the list contains no fewer than this number of elements. max_length Validates that the list contains no more than this number of elements. child Pass keyword constraints via a Param instance to to validate the members of the list. An example: from rest_typed import typed_api_view , Param , Query @typed_api_view ([ \"GET\" ]) def search_contacts ( emails : List [ str ] = Query ( max_length = 10 , child = Param ( format = \"email\" ))): # ORM logic here...","title":"List"},{"location":"views/supported_types/#enum","text":"Validates that the value of the input is one of a limited set of choices. Think of this as mapping to a Django REST ChoiceField . An example: from rest_typed import typed_api_view , Query class Straws ( str , Enum ): paper = \"paper\" plastic = \"plastic\" @typed_api_view ([ \"GET\" ]) def search_straws ( type : Straws = None ): # ORM logic here...","title":"Enum"},{"location":"views/supported_types/#typingliteral","text":"As an alternative to Enum , typing.Literal can validate that the value of the input is one of a limited set of choices. Think of this as mapping to a Django REST ChoiceField . An example: from typing import Literal @typed_api_view ([ \"GET\" ]) def search_straws ( type : Literal [ \"paper\" , \"plastic\" ] = None ): # ORM logic here...","title":"typing.Literal"},{"location":"views/supported_types/#django-rest-framework-serializers","text":"You can annotate view parameters with Django Rest serializers to validate request data and pass an instance of the serializer to the view. from rest_framework import serializers from rest_typed import typed_api_view class CommentSerializer ( serializers . Serializer ): email = serializers . EmailField () content = serializers . CharField ( max_length = 200 ) created = serializers . DateTimeField ( read_only = True ) \"\"\" POST { \"email\": \"mscott@paperco.com\", \"content\": \"great job team!\", } \"\"\" @typed_api_view ([ \"POST\" ]) def create_comment ( comment : CommentSerializer ): # is_valid() automatically called. # ready to access comment.validated_data","title":"Django REST Framework Serializers"},{"location":"views/supported_types/#drf-typed-tserializers","text":"You can annotate view parameters with DRF Typed's TSerializers to validate request data and pass an instance of the serializer to the view. from rest_typed.serializers import TSerializer from rest_typed import typed_api_view from datetime import datetime class CommentSerializer ( TSerializer ): email : str content : str created : datetime = serializers . DateTimeField ( read_only = True ) \"\"\" POST { \"email\": \"mscott@paperco.com\", \"content\": \"great job team!\", } \"\"\" @typed_api_view ([ \"POST\" ]) def create_comment ( comment : CommentSerializer ): # is_valid() automatically called. # ready to access comment.email and comment.content","title":"DRF Typed - TSerializers"},{"location":"views/supported_types/#pydanticbasemodel","text":"You can annotate view parameters with Pydantic models to validate request data and pass an instance of the model to the view. from pydantic import BaseModel from rest_typed import typed_api_view , Query class User ( BaseModel ): id : int name : str signup_ts : datetime = None friends : List [ int ] = [] \"\"\" POST { \"id\": 24529782, \"name\": \"Michael Scott\", \"friends\": [24529782] } \"\"\" @typed_api_view ([ \"POST\" ]) def create_user ( user : User ): # now have a user instance (assuming ValidationError wasn't raised)","title":"pydantic.BaseModel"},{"location":"views/third_party_schemas/","text":"Enabling Pydantic Schemas \u00b6 As an alternative to Django REST's serializers, you can annotate views with Pydantic models to have their parameters automatically validated and pass an instance of the Pydantic class to your method/function. To enable support, modify your settings: DRF_TYPED_VIEWS = { \"schema_packages\" : [ \"pydantic\" ] } These third-party packages must be installed in your virtual environment/runtime.","title":"Pydantic"},{"location":"views/third_party_schemas/#enabling-pydantic-schemas","text":"As an alternative to Django REST's serializers, you can annotate views with Pydantic models to have their parameters automatically validated and pass an instance of the Pydantic class to your method/function. To enable support, modify your settings: DRF_TYPED_VIEWS = { \"schema_packages\" : [ \"pydantic\" ] } These third-party packages must be installed in your virtual environment/runtime.","title":"Enabling Pydantic Schemas "}]}